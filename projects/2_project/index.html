<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Cyclically parallelized Treecode for Fast Computations of Electrostatic In teractions on Molecular Surfaces | Jiahui Chen</title> <meta name="author" content="Jiahui Chen"/> <meta name="description" content="treecode, electrostatics, parallel computing, MPI, load balancing"/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/uark.png"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jiahuic.github.io/projects/2_project/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Jiahui </span>Chen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching and Mentoring</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Submenus</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/cv/">CV</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/talks/">Talks</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Cyclically parallelized Treecode for Fast Computations of Electrostatic In teractions on Molecular Surfaces</h1> <p class="post-description">treecode, electrostatics, parallel computing, MPI, load balancing</p> </header> <article> <p>We study the parallelization of a flexible order Cartesian treecode algorithm for evaluating electrostatic potentials of charged particle systems in which \(N\) particles are located on the molecular surfaces of biomolecules such as proteins. When the well-separated condition is satisfied, the treecode algorithm uses a far-field Taylor expansion to compute \({O}(N\log{N})\) particle-cluster interactions to replace the \({O}(N^2)\) particle-particle interactions. The algorithm is implemented using the Message Passing Interface (MPI) standard by creating identical tree structures in the memory of each task for concurrent computing. We design a cyclic order scheme to uniformly distribute spatially-closed target particles to all available tasks, which significantly improves parallel load balancing. We also investigate the parallel efficiency subject to treecode parameters such as Taylor expansion order \(p\), maximum particles per leaf \(N_0\), and maximum acceptance criterion \(\theta\). This cyclically parallelized treecode can solve interactions among up to tens of millions of particles. However, if the problem size exceeds the memory limit of each task, a scalable domain decomposition (DD) parallelized treecode using an orthogonal recursive bisection (ORB) tree can be used instead. In addition to efficiently computing the \(N\)-body problem of charged particles, our approach can potentially accelerate GMRES iterations for solving the boundary integral Poisson-Boltzmann equation.</p> <h3 id="mpi-based-parallelization">MPI-based parallelization</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1  on the main task: 
2       read protein geometry data (atom locations) 
3       generate triangulation, and assign particles at triangle centroids with unit charges
4       copy particle locations to all other tasks 
5  on each task:
6       build local copy of tree and compute moments
7       compute assigned segment/group of source terms by direct sum
8       compute assigned segment/group of particle-cluster interaction by treecode
9       copy result to the main task
10  on the main task:
11      add segments/groups of all interactions and output result
</code></pre></div></div> <p>The treecode method requires low \(O(N)\) memory usage, and our focus is on computing interactions between induced charges on triangular elements characterizing molecular surfaces. We therefore store an identical copy of the entire tree on each MPI task (even for very large systems), permitting the application of a simple replicated data algorithm. Assuming that each MPI task has 24GB of available memory, our parallel algorithm can handle interactions between about 20 million charged particles, which is more than needed in this biological scenario. However, we note that for some three-dimensional applications, e.g.~in astrophysics, which have much larger numbers of particles, this approach of tree replication will rapidly limit scalability. To this end, we can alternatively apply a scalable domain decomposition (DD) parallelized treecode using an orthogonal recursive bisection (ORB) tree. Numerical results using both treecode parallelization strategies are provided for comparison.</p> <p>In treecode, we loop over target particles, and each particle can be treated as an independent interaction with the tree, whose copies are available on every task. Hence our implementation divides the particle array into \(n_p\) segments (for the sequential scheme, see below) or groups (for the cyclic scheme, see below) of size \(N/n_p\), where \(n_p\) is the number of tasks, and the segments/groups are processed concurrently. The pseudocode is shown in above table. Communications are handled using the <code class="language-plaintext highlighter-rouge">MPI_Allreduce</code> routine with the <code class="language-plaintext highlighter-rouge">MPI_SUM</code> reduction operation</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/project2/p2_f1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/project2/p2_f1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/project2/p2_f1-1400.webp"></source> <img src="/assets/img/project2/p2_f1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="cyclic-sequencial" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> (a) methods for assigning target particles to tasks: sequential order (top) vs cyclic order (bottom); (b) an illustration of an ORB tree using tasks 0-15 in four subdivisions. The binary code in color shows the partner of each task at different level. For example: task 0 \(\sim(0000)_2\) has task 8 \(\sim(1000)_2\), task 4 \(\sim(0100)_2\), task 2 \(\sim(0010)_2\), and task 1 \(\sim(0001)_2\) as its 0-1 partner at level 1 (red), level 2 (green), level 3 (purple), and level 4 (orange) respectively. </div> <h3 id="optimal-load-balancing">Optimal load balancing</h3> <p>The initial and intuitive method to assign target particles to tasks is to use <em>sequential ordering</em>, in which the 1st task handles the first \(N/n_p\) particles in a consecutive segment, the 2nd task handles the next \(N/n_p\) particles, etc. The illustration of this job assignment is shown in the top of the above figure (a). However, when examining the resulting CPU time on each task, we noticed starkly different times on each task, indicating a severe load imbalance. This may be understood by the fact that for particles at different locations, the types of interactions with the other particles through the tree can vary. For example, a particle with only a few close neighbors uses more particle-cluster interactions than particle-particle interactions, thus requiring less CPU time than a particle with many close neighbors. We also notice that for particles that are nearby one another, their interactions with other particles, either by particle-particle interaction or particle-cluster interaction, are quite similar, so some consecutive segments ended up computing many more particle-particle interactions than others that were instead dominated by particle-cluster interactions. Based on these observations, we designed a <em>cyclic ordering</em> scheme, as illustrated on the bottom of the above figure (a) to improve load balancing. In this scheme, particles nearby one another are uniformly distributed to different tasks. For example, for a group of particles close to each other, the first particle is handled by the first task, the second particle is handled by the second task, etc. The cycle repeats starting from the \((n_p+1)\)-th particle. The numerical results that follow demonstrate the significantly improved load balance from this simple scheme. We note that we also tried other approaches, such as using random numbers to assign particles to tasks, but these did not result in as significant improvements as the cyclic approach.</p> <h3 id="domain-decomposition-parallelized-treecode">Domain decomposition parallelized Treecode</h3> <p>The cyclically parallelized treecode algorithm has two significant advantages: easy implementation and high parallel efficiency. However, due to the fact that the entire tree is built on each task, the scale of the problem this algorithm can handle is limited by the memory capacity associated to each task. As a remedy, for very large problems beyond this memory limit, we implement a Domain Decomposition (DD) parallelized treecode under the framework of the orthogonal recursive bisection (ORB) tree from Salmon’s thesis, whose open source C++ implementation using the 0th moment (center of mass) is contributed by Barkman and Lin. Here we briefly describe the DD-parallelized treecode using the ORB tree structure.</p> <p>Starting from one rectangular domain containing all particles, the ORB treecode algorithm recursively divides particles into two equal amounts of groups by splitting the domain using an orthogonal hyperplane (perpendicular to the longest dimension of the domain) until the finest level in which the number of tasks equals the number of subdomains at that level as illustrated in the above figure (b). In this manner, each task, as loaded with the same number of particles, is associated to a subdomain and has a partner task (illustrated as the 0-1 difference using the same color in their binary code) at each level of the ORB tree division. Once the ORB tree is constructed, each task builds a local B-H tree based on their loaded particles, and communicates with its partner task at each level to exchange additional tree structure information such as clusters and their moments. Here cluster information is sent only when the maximum acceptance criteria (MAC) between particles of the receiving task and clusters on the sending task is satisfied. After this procedure each task stores only a small part of the entire tree such that the far fields are seen only at a coarse level while near fields are seen down to the leaves, as controlled by the MAC. Note that such a “local essential tree” is a subset of the full tree and is the necessary tree structure information for computing interactions between the task’s loaded particles and the entire tree. This is the major difference from the cyclically parallelized treecode in which the entire tree is built in the memory of each task. The details of constructing the ORB tree can be found in <a href="https://thesis.library.caltech.edu/6291/" target="_blank" rel="noopener noreferrer">link</a> and our new and additional contribution is to implement the <em>it arbitrary order</em> Taylor expansion as opposed to the original 0th order (center of mass) expansion. In updating the moments for lower levels of (larger) clusters using moments from higher levels of (smaller) clusters, a moments to moments (MtM) transformation as described in is applied.</p> <p><strong><em>Reference:</em></strong> <a href="https://www.sciencedirect.com/science/article/pii/S0010465520303672" target="_blank" rel="noopener noreferrer">https://www.sciencedirect.com/science/article/pii/S0010465520303672</a> <a href="/assets/pdf/paper-parallel_cyclic.pdf" target="_blank" rel="noopener noreferrer" class="float-right"><i class="fas fa-file-pdf"></i></a></p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Jiahui Chen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="noopener noreferrer">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>